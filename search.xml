<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis基础命令</title>
      <link href="2021/03/17/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>2021/03/17/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis数据存储格式："><a href="#Redis数据存储格式：" class="headerlink" title="Redis数据存储格式："></a>Redis数据存储格式：</h3><p>Redis自身是一个Map，其中所有的数据都是采用key：value的形式存储。</p><h3 id="Redis常用命令："><a href="#Redis常用命令：" class="headerlink" title="Redis常用命令："></a>Redis常用命令：</h3><table><thead><tr><th align="center">功能</th><th align="center">命令</th><th align="center">范例</th></tr></thead><tbody><tr><td align="center">设置数据</td><td align="center">set key value</td><td align="center">set name Tom</td></tr><tr><td align="center">获取数据</td><td align="center">get key</td><td align="center">get name</td></tr><tr><td align="center">清屏</td><td align="center">clear</td><td align="center">clear</td></tr><tr><td align="center">获取帮助</td><td align="center">help</td><td align="center">help</td></tr><tr><td align="center">退出</td><td align="center">quit/exit</td><td align="center">quit/exit</td></tr></tbody></table><h3 id="Redis数据类型-5种-："><a href="#Redis数据类型-5种-：" class="headerlink" title="Redis数据类型(5种)："></a>Redis数据类型(5种)：</h3><h4 id="string类型数据的基础操作："><a href="#string类型数据的基础操作：" class="headerlink" title="string类型数据的基础操作："></a>string类型数据的基础操作：</h4><ul><li><strong>添加/修改数据</strong></li></ul><table><thead><tr><th align="center">单个数据</th><th align="center">多个数据</th></tr></thead><tbody><tr><td align="center">set key value</td><td align="center">mset key1 value1 key2 value2 …</td></tr></tbody></table><ul><li><strong>获取数据</strong></li></ul><table><thead><tr><th align="center">单个数据</th><th align="center">多个数据</th></tr></thead><tbody><tr><td align="center">get key</td><td align="center">mget key1 key2 …</td></tr></tbody></table><ul><li><strong>删除数据</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><ul><li><strong>获取数据字符个数（字符串长度）</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><ul><li><strong>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><h4 id="string类型数据的扩展操作："><a href="#string类型数据的扩展操作：" class="headerlink" title="string类型数据的扩展操作："></a>string类型数据的扩展操作：</h4><h5 id="数据库分表场景："><a href="#数据库分表场景：" class="headerlink" title="数据库分表场景："></a>数据库分表场景：</h5><ul><li><strong>设置数值数据增加指定范围的值</strong></li></ul><table><thead><tr><th align="center">命令</th><th align="center">范例(num初始值为”1”)</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">incr key</td><td align="center">incr num</td><td align="center">num=”2”</td></tr><tr><td align="center">incrby key increment</td><td align="center">incrby num 10</td><td align="center">num=”12”</td></tr><tr><td align="center">incrbyfloat key increment</td><td align="center">incrbyfloat num 1.5</td><td align="center">num=”13.5”</td></tr></tbody></table><ul><li><strong>设置数值数据减少指定范围的值</strong></li></ul><table><thead><tr><th>命令</th><th>范例(num初始值为”15”)</th><th>结果</th></tr></thead><tbody><tr><td>decr key</td><td>decr num</td><td>num=”14”</td></tr><tr><td>decrby key increment</td><td>decrby num 10</td><td>num=”4”</td></tr></tbody></table><ul><li><p>string在Redis内部存储默认是一个字符串，当遇到增减类操作incr、decr时会转成数值类型进行计算。</p></li><li><p>Redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</p></li><li><p>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了Redis数值上限范围将报错。9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE）</p></li></ul><h6 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h6><ul><li><p>Redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性。</p></li><li><p>此方案适用于所有数据库，且支持数据库集群。</p></li></ul><h5 id="设置数据生命周期："><a href="#设置数据生命周期：" class="headerlink" title="设置数据生命周期："></a>设置数据生命周期：</h5><ul><li><strong>设置数据具有制定的生命周期</strong></li></ul><table><thead><tr><th align="center">命令</th><th align="center">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">setex key seconds value</td><td align="center">setex  num 10 Tom</td><td align="center">10秒后数据消失</td></tr><tr><td align="center">psetex key milliseconds value</td><td align="center">psetex num 1000 Tom</td><td align="center">1000毫秒后数据消失</td></tr></tbody></table><h6 id="tips：-1"><a href="#tips：-1" class="headerlink" title="tips："></a>tips：</h6><ul><li>Redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作。</li></ul><h5 id="string类型数据操作的注意事项："><a href="#string类型数据操作的注意事项：" class="headerlink" title="string类型数据操作的注意事项："></a>string类型数据操作的注意事项：</h5><p>数据操作不成功的反馈与数据正常操作之间的差异</p><p>①表示运行结果是否成功</p><ul><li><p>（integer）0 —&gt; false 失败</p></li><li><p>（integer）1 —&gt; true 成功</p></li></ul><p>②表示运行结果</p><ul><li><p>（integer）3 —&gt; 3 3个</p></li><li><p>（integer）1 —&gt; 1 1个</p></li><li><p>数据未获取到</p><p>（nil）等同于null</p></li><li><p>数据最大存储量</p><p>512MB</p></li><li><p>数值计算最大范围(java中long的最大值)</p><p>±9223372036854775807</p></li></ul><h5 id="key的设置约定"><a href="#key的设置约定" class="headerlink" title="key的设置约定"></a>key的设置约定</h5><p>表名 ：主键名 ：主键值 ： 字段名</p><hr><h5 id="hash类型数据的基础操作："><a href="#hash类型数据的基础操作：" class="headerlink" title="hash类型数据的基础操作："></a>hash类型数据的基础操作：</h5><p>（待写……）</p><h5 id="list类型数据的基础操作："><a href="#list类型数据的基础操作：" class="headerlink" title="list类型数据的基础操作："></a>list类型数据的基础操作：</h5><p>（待写……）</p><h5 id="set类型数据的基础操作："><a href="#set类型数据的基础操作：" class="headerlink" title="set类型数据的基础操作："></a>set类型数据的基础操作：</h5><p>（待写……）</p><h5 id="sorted-set类型数据的基础操作："><a href="#sorted-set类型数据的基础操作：" class="headerlink" title="sorted_set类型数据的基础操作："></a>sorted_set类型数据的基础操作：</h5><p>（待写……）</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单列设计模式</title>
      <link href="2021/03/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么会有单列设计模式？"><a href="#为什么会有单列设计模式？" class="headerlink" title="为什么会有单列设计模式？"></a>为什么会有单列设计模式？</h3><p>当应用程序中创建了多个实例时可能会造成资源的浪费。并且多次调用多个实例操作数据时容易造成结果错误。而单例模式能保证应用程序中有且只有一个实例。可以保证一个类在内存中的对象的唯一性，在一些常用的工具类、线程池、缓存、数据库等程序中可能只允许我们创建一个对象。</p><h3 id="单例模式的设计思想"><a href="#单例模式的设计思想" class="headerlink" title="单例模式的设计思想"></a>单例模式的设计思想</h3><p>单例模式的关键在于保证应用程序中有且仅有一个对象，如何保证只有一个对象呢？其实只需要三步就可以保证对象的唯一性：</p><p>（1）不允许其他类new对象</p><p>（2）在本类中创建对象</p><p>（3）对外提供一个可以让其他类获取该对象方法</p><p>将上面步骤转化为代码描述为：</p><p>（1）私有化本类的构造方法</p><p>（2）通过new关键字在本类中创建一个本类对象</p><p>（3）定义一个公有方法，将在本类中创建的对象返回</p><h3 id="单例模式的java代码实现："><a href="#单例模式的java代码实现：" class="headerlink" title="单例模式的java代码实现："></a>单例模式的java代码实现：</h3><p>单例模式可以分为两大类：饿汉式、懒汉式。</p><p>饿汉式和懒汉式的区别：</p><ul><li><p>饿汉式：指全局的单例实例在类装载时构建。</p></li><li><p>懒汉式：指全局的单例实例在第一次被使用时构建。</p></li></ul><p>单例模式的写法大致可以分为5类：懒汉式、饿汉式、双重校验锁、静态内部类、枚举。</p><h4 id="单例模式的饿汉式（可用）"><a href="#单例模式的饿汉式（可用）" class="headerlink" title="单例模式的饿汉式（可用）"></a>单例模式的饿汉式（可用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>优点：</p><p>实现简单，在类加载时就完成了实例化，避免了线程同步问题。</p><p>缺点：</p><p>由于在类加载时就完成实例化，所以没有达到（Lazy Loading）懒加载的效果，也就是说可能我没有用到这个实例它也会创建，会造成内存浪费（但是这个浪费可以忽略，所以也是推荐使用的）。</p><h4 id="单例模式的饿汉式变换写法（可用）"><a href="#单例模式的饿汉式变换写法（可用）" class="headerlink" title="单例模式的饿汉式变换写法（可用）"></a>单例模式的饿汉式变换写法（可用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>其实这种写法和上一种写法一样，都是在类初始化时创建对象的，它的优缺点和上面一样，只是写法有点不同，可以归为一种写法。</p><h4 id="单例模式的懒汉式（线程不安全，不可用）"><a href="#单例模式的懒汉式（线程不安全，不可用）" class="headerlink" title="单例模式的懒汉式（线程不安全，不可用）"></a>单例模式的懒汉式（线程不安全，不可用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">           singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>这种方式是在调用getSingleton()方法时才创建对象，它相对于饿汉式比较懒，因此被称为懒汉式。</p><p>上述这种写法其实是存在线程安全问题的，那为什么会存在线程安全问题呢？</p><p>是因为在运行过程中可能会存在这么一种情况：当有多个线程去调用getSingleton()方法来获取Singleton的实例时，第一个线程在执行if(singleton == null)这个语句时，此时singleton 是为null，进入语句。在还没有执行singleton = new Singleton()时（此时singleton还是为null的）第二个线程也进入if(singleton == null)这个语句，因为第一个线程还没有执行singleton = new Singleton()，所以它会继续执行singleton = new Singleton()语句来实例化Singleton对象，因为第二个线程也进入了if语句，所以它也会实例化一个Singleton对象。这样就导致实例化了两个Singleton对象。所以它是存在线程安全的。</p><h4 id="线程安全的懒汉式（线程安全，效率低不推荐使用）"><a href="#线程安全的懒汉式（线程安全，效率低不推荐使用）" class="headerlink" title="线程安全的懒汉式（线程安全，效率低不推荐使用）"></a>线程安全的懒汉式（线程安全，效率低不推荐使用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">           singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>虽然通过加锁的方式解决了上面一种写法的线程安全问题，但是效率低。</p><p>缺点：</p><p>效率低，每个线程想要获得Singleton对象的时候，执行getSingleton()方法都要进行同步。而其实这个方法只需要执行一次实例化代码就够了，后面想要获得Singleton对象，直接return就行了。方法进行同步效率太低需要改进。</p><h4 id="单例模式的懒汉式（线程不安全，不可用）-1"><a href="#单例模式的懒汉式（线程不安全，不可用）-1" class="headerlink" title="单例模式的懒汉式（线程不安全，不可用）"></a>单例模式的懒汉式（线程不安全，不可用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>由于上面一种写法效率太低，可能有人会想到这种写法。其实这种写法跟（3）的写法一样是线程不安全的。当一个线程还没有实例化Singleton时，另一个线程执行到if(singleton == null)语句时就会进入到if语句，虽然加了锁，但等到第一个线程执行完singleton = new Singleton()跳出这个锁时，另一个已经进入if语句的线程同样会实例化一个新的Singleton对象。线程不安全的原理跟（3）中的类似，因此这种方法并不可行。</p><h4 id="单例模式懒汉式双重校验锁（推荐使用）"><a href="#单例模式懒汉式双重校验锁（推荐使用）" class="headerlink" title="单例模式懒汉式双重校验锁（推荐使用）"></a>单例模式懒汉式双重校验锁（推荐使用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>这一版代码解决了（3）和（4）中存在的问题，其中有两次if(singleton == null)的判断，这个叫做【双重检查 Double-Check】。</p><ul><li><p>第一个if(singleton == null)，其实是为了解决（4）中效率问题，只有singleton为null时，才进入synchronized的代码段。</p></li><li><p>第二个if(singleton == null)则是为了解决（3）中的线程安全问题，防止多线程可能实例多个对象的情况。</p></li></ul><p>volatile关键字是为了防止指令重排出现错误，就是说，由于有一个singleton不为null了，但是仍没有完成初始化的中间态，而这个时候，如果有其他线程刚好运行到第一层if语句，这里读取的singleton已经不为null了，所以直接把这个中间态的singleton拿去用，就会产生问题。（涉及原子操作、指令重排知识，volatile关键字的一个作用是禁止指令重排）</p><p>优点：</p><p>线程安全；延迟加载；效率较高</p><h4 id="内部类（推荐使用）"><a href="#内部类（推荐使用）" class="headerlink" title="内部类（推荐使用）"></a>内部类（推荐使用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">Singleton singleton = Singleton.getSingleton();</span><br></pre></td></tr></table></figure><p>它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但从外部看又的确是懒汉式实现</p><p>优点：</p><p>避免了线程不安全；延迟加载；效率高。</p><h4 id="枚举（极推荐使用）"><a href="#枚举（极推荐使用）" class="headerlink" title="枚举（极推荐使用）"></a>枚举（极推荐使用）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">SingletonEnum.singleton.method();</span><br></pre></td></tr></table></figure><p>由于创建枚举实例的过程是线程安全的，所以这种写法也没有同步的问题。</p><p>优点：</p><p>这种写法在功能上与共有域方法相近，但它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。</p><hr><p><strong>如有错误欢迎指出</strong>！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="2021/03/04/article-title/"/>
      <url>2021/03/04/article-title/</url>
      
        <content type="html"><![CDATA[<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><hr><h3 id="1、什么是冒泡排序？"><a href="#1、什么是冒泡排序？" class="headerlink" title="1、什么是冒泡排序？"></a>1、什么是冒泡排序？</h3><p>&ensp;&ensp;&ensp;&ensp;我们把相邻的元素进行两两比较，根据大小来交换元素的位置。</p><p>&ensp;&ensp;&ensp;&ensp;原始的冒泡排序是稳定排序，由于该排序算法的每一轮都要遍历所有元素，轮转的次数和元素数量相当，所以时间复杂度是O（N^2）</p><hr><h3 id="2、java代码实现及优化："><a href="#2、java代码实现及优化：" class="headerlink" title="2、java代码实现及优化："></a>2、java代码实现及优化：</h3><h4 id="（1）原始的冒泡排序："><a href="#（1）原始的冒泡排序：" class="headerlink" title="（1）原始的冒泡排序："></a>（1）原始的冒泡排序：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="（2）冒泡排序优化一："><a href="#（2）冒泡排序优化一：" class="headerlink" title="（2）冒泡排序优化一："></a>（2）冒泡排序优化一：</h4><p>&ensp;&ensp;&ensp;&ensp;从上一版代码可以很明显看出，自从经过第六轮排序，整个数列已然是有序的了。但是排序算法仍然继续执行第七轮、第八轮。这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="comment">//有序标记，判断数组是否有序，初始值为true（true表示有序，false表示无序）</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是有序数组，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;这一版代码利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。</p><hr><h4 id="（3）冒泡排序优化二："><a href="#（3）冒泡排序优化二：" class="headerlink" title="（3）冒泡排序优化二："></a>（3）冒泡排序优化二：</h4><p>&ensp;&ensp;&ensp;&ensp;按照上一版代码的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2，以此类推……。实际上，数列真正的有序区可能会大于这个长度，比如{3,4,2,1,5,6,7,8}数组的第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。</p><p>&ensp;&ensp;&ensp;&ensp;当对于{3,4,2,1,5,6,7,8}这种特殊数据时，后半部分{……,5,6,7,8}已经是有序的,因此可以通过对数列的有序区做界定，在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的标记，每次只需比较到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="comment">//有序标记，判断数组是否有序，初始值为true（true表示有序，false表示无序）</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//只比较到无序数列边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">                lastExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">        sortBorder = lastExchangeIndex;</span><br><span class="line">        <span class="comment">//如果是有序数组，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。</p><hr><p><strong>&ensp;&ensp;&ensp;&ensp;如有错误欢迎留言！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/04/hello-world/"/>
      <url>2021/03/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
